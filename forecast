#!/usr/bin/env python3

import argparse, re, sys, requests, datetime, pytz
from itertools import chain

def get_weather_forecast(latitude, longitude, requested_date, model):
    params = {
        'latitude': latitude,
        'longitude': longitude,
        'hourly': 'temperature_2m,precipitation',
        'models': model,
        'forecast_days': 16
    }

    response = requests.get('https://api.open-meteo.com/v1/forecast', params=params)
    response.raise_for_status()
    data = response.json()

    times = data['hourly']['time']
    temperatures = data['hourly']['temperature_2m']
    precipitations = data['hourly']['precipitation']
    assert data["timezone"] == "GMT"

    now = datetime.datetime.now(datetime.timezone.utc).astimezone()
    out_times = []
    out_temps = []
    out_precips = []
    for time, temp, precip in zip(times, temperatures, precipitations):
        if temp is None:
            continue # stepped outside the forecast
        time_gmt = datetime.datetime.fromisoformat(time).replace(tzinfo=datetime.timezone.utc)
        time_local = time_gmt.astimezone()
        if time_local.date() == requested_date and time_local > now:
            out_times.append(time_local)
            out_temps.append(temp)
            out_precips.append(precip)
    return out_times, out_temps, out_precips

def pretty_print(headers, *data):
    data_widths = [max(len(str(n)) for n in chain(column, [''])) for column in data]
    header_widths = [len(h) for h in headers]
    widths = [max(hw, dw) for hw, dw in zip(data_widths, header_widths)]
    for width, header in zip(widths, headers):
        print(f"{header:<{width}} ", end='')
    print()
    for row in zip(*data):
        for width, n in zip(widths, row):
            print(f"{str(n):>{width}} ", end='')
        print()

def resolve_place(s):
    if mtch := re.fullmatch(r"(-?\d+\.\d+),(-?\d+\.\d+)", s):
        latitude, longitude = float(mtch.group(1)), float(mtch.group(2))
        if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180):
            raise ValueError("Latitude must be between -90 and 90, longitude between -180 and 180")
        return s, latitude, longitude
    response = requests.get('https://nominatim.openstreetmap.org/search.php',
                            params={'q': s, 'format': 'jsonv2'},
                            headers={'User-Agent': 'curl/8.9.1'})
    response.raise_for_status()
    places = response.json()
    if not places:
        raise ValueError("unknown place")
    place = places[0]
    return place['display_name'], float(place['lat']), float(place['lon'])

def parse_date(s):
    if s == "today":
        return datetime.date.today()
    if s == "tomorrow":
        return datetime.date.today() + datetime.timedelta(1)
    return datetime.datetime.strptime(s, '%Y-%m-%d').date()

def main():
    parser = argparse.ArgumentParser(description="Fetch weather forecast from OpenMeteo API for a given location and date.")
    parser.add_argument('place', help="Named location or lat,long pair")
    parser.add_argument('date', nargs='?', default='today', help="Date for the forecast in YYYY-MM-DD format, or 'today' or 'tomorrow'")
    parser.add_argument('--model', default='gfs_graphcast025', help="Forecast model to use - e.g. gfs_graphcast025, icon_eu, ecmwf_ifs025")
    args = parser.parse_args()

    place_name, latitude, longitude = resolve_place(args.place)
    date = parse_date(args.date)

    print(f"{args.model} forecast for {place_name}")
    times, temps, precips = get_weather_forecast(latitude, longitude, date, args.model)
    pretty_print(
        ["Date", "Hour", "Temp[Â°C]", "Rain[mm]"],
        [dt.date() if i == 0 else '' for (i, dt) in enumerate(times)],
        [dt.strftime('%H:%M') for dt in times],
        temps,
        list(map("{:g}".format, precips))
    )

if __name__ == "__main__":
    main()
