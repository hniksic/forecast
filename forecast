#!/usr/bin/env python3

import argparse, re, sys, requests, datetime, pytz

def download_forecast(latitude, longitude, model):
    params = {
        'latitude': latitude,
        'longitude': longitude,
        'hourly': 'temperature_2m,precipitation',
        'models': model,
        'forecast_days': 16,
        'timezone': 'auto',
    }

    response = requests.get('https://api.open-meteo.com/v1/forecast', params=params)
    response.raise_for_status()
    data = response.json()

    times = data['hourly']['time']
    temperatures = data['hourly']['temperature_2m']
    precipitations = data['hourly']['precipitation']

    timezone = pytz.timezone(data['timezone'])
    now = datetime.datetime.now(timezone)

    return times, temperatures, precipitations, timezone, now

def filter_for_date(times, temperatures, precipitations, timezone, now, requested_date):
    if requested_date == "today":
        requested_date = now.date()
    elif requested_date == "tomorrow":
        requested_date = now.date() + datetime.timedelta(1)

    out_times = []
    out_temps = []
    out_precips = []
    for time, temp, precip in zip(times, temperatures, precipitations):
        if temp is None:
            continue # stepped outside the forecast
        tm = timezone.localize(datetime.datetime.fromisoformat(time))
        if tm.date() == requested_date and tm > now:
            out_times.append(tm)
            out_temps.append(temp)
            out_precips.append(precip)
    return out_times, out_temps, out_precips

def pretty_print(headers, *data):
    data_widths = [max((len(str(n)) for n in column), default=0) for column in data]
    header_widths = [len(h) for h in headers]
    widths = [max(hw, dw) for hw, dw in zip(data_widths, header_widths)]
    print(" ".join(f"{header:<{width}} " for width, header in zip(widths, headers)))
    for row in zip(*data):
        print(" ".join(f"{str(n):>{width}} " for width, n in zip(widths, row)))

def resolve_place(s):
    if mtch := re.fullmatch(r"(-?\d+\.\d+),(-?\d+\.\d+)", s):
        latitude, longitude = float(mtch.group(1)), float(mtch.group(2))
        if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180):
            raise ValueError("Latitude must be between -90 and 90, longitude between -180 and 180")
        return s, latitude, longitude
    response = requests.get('https://nominatim.openstreetmap.org/search.php',
                            params={'q': s, 'format': 'jsonv2'},
                            headers={'User-Agent': 'curl/8.9.1'})
    response.raise_for_status()
    places = response.json()
    if not places:
        raise ValueError("unknown place")
    place = places[0]
    return place['display_name'], float(place['lat']), float(place['lon'])

def parse_date_range(s):
    if s in ("today", "tomorrow"):
        return [s]
    if (pos := s.find('..')) != -1:
        a = datetime.datetime.strptime(s[:pos], '%Y-%m-%d').date()
        b = datetime.datetime.strptime(s[pos + 2:], '%Y-%m-%d').date()
        dates = []
        while a <= b:
            dates.append(a)
            a += datetime.timedelta(1)
    else:
        dates = [datetime.datetime.strptime(s, '%Y-%m-%d').date()]
    return dates

def main():
    parser = argparse.ArgumentParser(description="Fetch weather forecast from OpenMeteo API for a given location and dates.")
    parser.add_argument('place', help="Location name or lat,long pair")
    parser.add_argument('dates', nargs='?', default='today',
                        help="YYYY-MM-DD (single), YYYY-MM-DD..YYYY-MM-DD (inclusive range), 'today' or 'tomorrow'")
    parser.add_argument('--model', default='gfs_graphcast025', help="Forecast model to use - e.g. gfs_graphcast025, icon_eu, ecmwf_ifs025")
    args = parser.parse_args()

    place_name, latitude, longitude = resolve_place(args.place)
    try:
        dates = parse_date_range(args.dates)
    except ValueError as e:
        print(f"{sys.argv[0]}: dates must be YYYY-MM-DD, YYYY-MM-DD..YYYY-MM-DD, 'today' or 'tomorrow'", file=sys.stderr)
        sys.exit(1)

    print(f"{args.model} forecast for {place_name}")
    forecast = download_forecast(latitude, longitude, args.model)
    all_dates, all_times, all_temps, all_precips = [], [], [], []

    for date in dates:
        times, temps, precips = filter_for_date(*forecast, date)
        all_dates.extend(dt.date() if i == 0 else '' for (i, dt) in enumerate(times))
        all_times.extend(dt.strftime('%H:%M') for dt in times)
        all_temps.extend(temps)
        all_precips.extend('0' if p == 0 else str(p) for p in precips)

    pretty_print(
        ["Date", "Time", "Temp[Â°C]", "Rain[mm]"],
        all_dates, all_times, all_temps, all_precips
    )

if __name__ == "__main__":
    main()
