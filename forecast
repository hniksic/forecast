#!/usr/bin/env python3

import argparse, itertools, re, sys, requests, datetime, pytz

def download_forecast(latitude, longitude, models):
    params = {
        'latitude': latitude,
        'longitude': longitude,
        'hourly': 'temperature_2m,precipitation',
        'models': ','.join(models),
        'forecast_days': 16,
        'timezone': 'auto',
    }

    response = requests.get('https://api.open-meteo.com/v1/forecast', params=params)
    response.raise_for_status()
    data = response.json()

    timezone = pytz.timezone(data['timezone'])
    times = [timezone.localize(datetime.datetime.fromisoformat(time)) for time in data['hourly']['time']]

    propname = lambda prop, model: prop if len(models) == 1 else f'{prop}_{model}'
    forecast = {
        model: (data['hourly'][propname('temperature_2m', model)],
                data['hourly'][propname('precipitation', model)])
        for model in models
    }

    return times, forecast, timezone

# assert dedup(["foo", "foo", "foo", "bar", "bar", "baz"]) == ["foo", "", "", "bar", "", "baz"]
def dedup(iterable):
    return ["" if i > 0 else k for k, g in itertools.groupby(iterable) for i in range(len(list(g)))]

def extract_forecast_table(times, by_model, time_range, model_to_short):
    start_time, end_time = time_range
    in_range = lambda dt: start_time <= dt < end_time

    headers = ["Date", "Hour"]
    columns = []
    columns.append(dedup(dt.date() for dt in times if in_range(dt)))
    columns.append([dt.strftime('%H') for dt in times if in_range(dt)])

    for model, data in by_model.items():
        temps, precips = [], []
        for time, temp, precip in zip(times, *data):
            if not in_range(time):
                continue
            temps.append(temp)
            precips.append(str(precip) if precip != 0 else '0')
        headers.append(f"T/Â°C ({model_to_short[model]})")
        columns.append(temps)
        headers.append(f"Rain/mm ({model_to_short[model]})")
        columns.append(precips)

    return headers, columns

#assert shorten(["foo", "bar"]) == ["f", "b"]
#assert shorten(["foo", "foobar"]) == ["foo", "foob"]
#assert shorten(["graphcast", "ecmwf", "geo"]) == ["gr", "e", "ge"]
def shorten(strings):
    result = [s[0] if s else '' for s in strings]
    n = len(strings)
    while True:
        seen = {}
        duplicates = set()
        for i, s in enumerate(result):
            if s in seen:
                duplicates.add(i)
                duplicates.add(seen[s])
            else:
                seen[s] = i
        if not duplicates:
            break
        # For each string with duplicates, try longer prefix
        for i in duplicates:
            if len(strings[i]) > len(result[i]):
                result[i] = strings[i][:len(result[i]) + 1]
            else:
                # If at max length, keep as is
                result[i] = strings[i]
    return result

def pretty_print(headers, *data):
    data_widths = [max((len(str(n)) for n in column), default=0) for column in data]
    header_widths = [len(h) for h in headers]
    widths = [max(hw, dw) for hw, dw in zip(data_widths, header_widths)]
    print(" ".join(f"{header:<{width}} " for width, header in zip(widths, headers)))
    for row in zip(*data):
        print(" ".join(f"{str(n):>{width}} " for width, n in zip(widths, row)))

def resolve_place(s):
    if mtch := re.fullmatch(r"(-?\d+\.\d+),(-?\d+\.\d+)", s):
        latitude, longitude = float(mtch.group(1)), float(mtch.group(2))
        if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180):
            raise ValueError("Latitude must be between -90 and 90, longitude between -180 and 180")
        return s, latitude, longitude
    response = requests.get('https://nominatim.openstreetmap.org/search.php',
                            params={'q': s, 'format': 'jsonv2'},
                            headers={'User-Agent': 'curl/8.9.1'})
    response.raise_for_status()
    places = response.json()
    if not places:
        raise ValueError("unknown place")
    place = places[0]
    return place['display_name'], float(place['lat']), float(place['lon'])

def parse_date(s):
    if s in ("today", "tomorrow"):
        return s
    return datetime.datetime.strptime(s, '%Y-%m-%d').date()

def parse_date_range(s):
    if (pos := s.find('..')) != -1:
        a = parse_date(s[:pos])
        b = parse_date(s[pos +2:])
        return a, b
    else:
        d = parse_date(s)
        return d, d

def resolve_date(dt, today):
    if dt == "today":
        return today
    if dt == "tomorrow":
        return today + datetime.timedelta(1)
    return dt

def main():
    parser = argparse.ArgumentParser(description="Fetch weather forecast from OpenMeteo API for a given location and dates.")
    parser.add_argument('place', help="Location name or lat,long pair")
    parser.add_argument('dates', nargs='?', default='today',
                        help="YYYY-MM-DD (single), YYYY-MM-DD..YYYY-MM-DD (inclusive range), 'today' or 'tomorrow'")
    parser.add_argument('--models', default='gfs_graphcast025,ecmwf_ifs025', type=lambda s: s.split(','), help="Comma-separated list of forecast models - e.g. gfs_graphcast025,icon_eu,ecmwf_ifs025")
    args = parser.parse_args()

    place_name, latitude, longitude = resolve_place(args.place)
    try:
        date_range = parse_date_range(args.dates)
    except ValueError as e:
        print(f"{sys.argv[0]}: dates must be YYYY-MM-DD, YYYY-MM-DD..YYYY-MM-DD, 'today' or 'tomorrow'", file=sys.stderr)
        sys.exit(1)

    short_models = shorten(args.models)
    model_to_short = {m: s for m, s in zip(args.models, short_models)}
    explanation = ", ".join(f"{s}={m}" for m, s in model_to_short.items())
    print(f"Forecast for {place_name} ({explanation})")

    in_times, by_model, timezone = download_forecast(latitude, longitude, args.models)
    now = datetime.datetime.now(timezone)
    start_date, end_date = tuple(resolve_date(dt, now.date()) for dt in date_range)
    start_time = timezone.localize(datetime.datetime(start_date.year, start_date.month, start_date.day, 0, 0, 0))
    start_time = max(start_time, now)
    end_date += datetime.timedelta(1)
    end_time = timezone.localize(datetime.datetime(end_date.year, end_date.month, end_date.day, 0, 0, 0))

    headers, columns = extract_forecast_table(in_times, by_model, (start_time, end_time), model_to_short)
    pretty_print(headers, *columns)

if __name__ == "__main__":
    main()
